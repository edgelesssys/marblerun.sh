<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Marblerun - The control plane for confidential computing on Marblerun - The Control Plane for Confidential Computing</title><link>https://marblerun.sh/</link><description>Recent content in Marblerun - The control plane for confidential computing on Marblerun - The Control Plane for Confidential Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 19 Jan 2021 15:33:00 +0100</lastBuildDate><atom:link href="https://marblerun.sh/index.xml" rel="self" type="application/rss+xml"/><item><title>Defining a Manifest</title><link>https://marblerun.sh/docs/workflows/define-manifest/</link><pubDate>Thu, 19 Nov 2020 16:44:36 +0100</pubDate><guid>https://marblerun.sh/docs/workflows/define-manifest/</guid><description>Defining a Manifest The Manifest is a simple JSON file that determines the key properties of your cluster: Packages, Marbles, Secrets, and RecoveryKeys. This article describes how to define these in your manifest.json.
Manifest:Packages The Packages section of the Manifest lists all the secure enclave software packages that your application uses. A package is defined by the following properties.
UniqueID: this value will pin this package to one specific release build of an application.</description></item><item><title>Attestation</title><link>https://marblerun.sh/docs/features/attestation/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/features/attestation/</guid><description>Attestation Hardware-rooted remote attestation is a key ingredient for distributed confidential apps. Marblerun relies heavily on the Data Center Attestation Primitives (DCAP) of the latest SGX-enabled Intel Xeon processors. At the time of writing, only Microsoft Azure had a public DCAP service deployed in their data centers. Hence, our demos are heavily tested and deployed on Azure Kubernetes Service (AKS). However, Marblerun works with any DCAP service complying with the SGX specification.</description></item><item><title>Coordinator API</title><link>https://marblerun.sh/docs/reference/coordinator/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/reference/coordinator/</guid><description>Coordinator client API JSend response style Endpoints /manifest /quote /recover /status /update JSend response style The Client API is designed as an HTTP-REST interface. Responses follow the JSend style, though only the response types success and error are returned so far.
In general, a successful API call (HTTP Code 200) will return a response in the following style:
{ &amp;#34;status&amp;#34;: &amp;#34;success&amp;#34;, &amp;#34;data&amp;#34;: { &amp;#34;ManifestSignature&amp;#34;: &amp;#34;3fff78e99dd9bd801e0a3a22b7f7a24a492302c4d00546d18c7f7ed6e26e95c3&amp;#34; } } Depending on the API endpoint and the data submitted, data might contain a specific answer from the coordinator, or may just be null to acknowledge that the requested operation was performed successfully.</description></item><item><title>Introduction</title><link>https://marblerun.sh/docs/introduction/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/introduction/</guid><description>Introduction Marblerun is a framework for creating distributed confidential computing apps.
Build your confidential microservices with EGo or another runtime, distribute them with Kubernetes on an SGX-enabled cluster, and let Marblerun take care of the rest. Deploy end-to-end secure and verifiable AI pipelines or crunch on sensitive big data in the cloud. Confidential computing at scale has never been easier.
Marblerun guarantees that the topology of your distributed app adheres to a Manifest specified in simple JSON.</description></item><item><title>Quickstart</title><link>https://marblerun.sh/docs/getting-started/quickstart/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/getting-started/quickstart/</guid><description>Quickstart In this guide, we’ll walk you through how to install Marblerun into your Kubernetes cluster. Then we’ll deploy a sample confidential application to demonstrate the capabilities of Marblerun.
Installing Marblerun is easy. First, you will install the CLI (command-line interface) onto your local machine. Using this CLI, you’ll then install the control plane onto your Kubernetes cluster. Finally, you will add your own services and set up a corresponding Manifest.</description></item><item><title>Concepts</title><link>https://marblerun.sh/docs/getting-started/concepts/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/getting-started/concepts/</guid><description>Concepts This article describes the concepts of confidential computing and service meshes which are key to the Marblerun approach.
Confidential computing Confidential computing protects data in use by performing computations in hardware-based secure enclaves. The most prominent enclave to date is probably Intel SGX. Enclaves prevent unauthorized access or modification of applications and data while in use, thereby increasing the security assurances for organizations that manage sensitive and regulated data. For information about confidential computing, see the Confidential Computing Consortium white paper.</description></item><item><title>Recovery</title><link>https://marblerun.sh/docs/features/recovery/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/features/recovery/</guid><description>Recovery Persistent storage for confidential applications in the cloud requires a bit of attention. By design, SGX sealing keys are unique to a single CPU, which means using the default SGX sealing methods has some caveats. For example, sealing data while running on one host could mean the data can&amp;rsquo;t be unsealed when running on another host later on.
As described in our secrets management chapter, the Coordinator provides Marbles with virtual sealing keys making persistence straightforward for your applications.</description></item><item><title>Setting a Manifest</title><link>https://marblerun.sh/docs/workflows/set-manifest/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/set-manifest/</guid><description>Setting a Manifest The Manifest is a JSON document that defines which services span the mesh and how they should be configured. It further defines what Infrastructure providers are allowed. You can set a Manifest through Marblerun&amp;rsquo;s Client REST-API. The endpoint for all Manifest operations is /manifest.
See the following Manifest for example (manifest.json).
{ &amp;#34;Packages&amp;#34;: { &amp;#34;backend&amp;#34;: { &amp;#34;UniqueID&amp;#34;: &amp;#34;6b2822ac2585040d4b9397675d54977a71ef292ab5b3c0a6acceca26074ae585&amp;#34;, &amp;#34;ProductID&amp;#34;: 43, &amp;#34;SecurityVersion&amp;#34;: 1, &amp;#34;Debug&amp;#34;: false }, &amp;#34;frontend&amp;#34;: { &amp;#34;SignerID&amp;#34;: &amp;#34;43361affedeb75affee9baec7e054a5e14883213e5a121b67d74a0e12e9d2b7a&amp;#34;, &amp;#34;ProductID&amp;#34;: 42, &amp;#34;SecurityVersion&amp;#34;: 3, &amp;#34;Debug&amp;#34;: true } }, &amp;#34;Marbles&amp;#34;: { &amp;#34;backend_first&amp;#34;: { &amp;#34;Package&amp;#34;: &amp;#34;backend&amp;#34;, &amp;#34;MaxActivations&amp;#34;: 1, &amp;#34;Parameters&amp;#34;: { &amp;#34;Files&amp;#34;: { &amp;#34;/tmp/defg.</description></item><item><title>CLI</title><link>https://marblerun.sh/docs/reference/cli/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/reference/cli/</guid><description>Command Line Interface (CLI) We provide a command-line interface (CLI) for Marblerun. This CLI allows you to install Marblerun on your cluster and interacts with the control plane through the Client API for all administrative tasks in the service mesh.
Installation Requirements Command certificate root intermediate chain Command check Command completion Command graphene-prepare Command install Command manifest set update get signature Command namespace add remove list Command precheck Command recover Command status Command uninstall Command version Installation To install the Marblerun CLI on your machine you can use our pre-built binaries.</description></item><item><title>Cloud</title><link>https://marblerun.sh/docs/deployment/cloud/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/deployment/cloud/</guid><description>Cloud deployment This guide walks you through setting up Marblerun on different CSP offerings individually.
Azure confidential computing VMs Azure confidential computing services are generally available and provide access to VMs with Intel SGX enabled in DCsv2 VM instances. The description below uses a VM running Ubuntu 18.04.
Prerequisites Update and install EGo Update and install the Azure DCAP client Deploy Marblerun You can run Marblerun standalone on your Azure DCsv2 VM, see our standalone guide.</description></item><item><title>Coordinator</title><link>https://marblerun.sh/docs/getting-started/coordinator/</link><pubDate>Thu, 19 Nov 2020 16:30:52 +0100</pubDate><guid>https://marblerun.sh/docs/getting-started/coordinator/</guid><description>Coordinator The Coordinator is Marblerun&amp;rsquo;s control plane. It communicates with the Marble&amp;rsquo;s data plane through gRPC and provides an HTTP-REST interface on the client-side. The Coordinator can be configured with several environment variables:
EDG_COORDINATOR_MESH_ADDR: The listener address for the gRPC server EDG_COORDINATOR_CLIENT_ADDR: The listener address for the HTTP server EDG_COORDINATOR_DNS_NAMES: The DNS names for the cluster&amp;rsquo;s root certificate EDG_COORDINATOR_SEAL_DIR: The file path for storing sealed data The Coordinator clients can be divided into two major groups.</description></item><item><title>Adding a service</title><link>https://marblerun.sh/docs/workflows/add-service/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/add-service/</guid><description>Adding a service Adding a service to your application requires three steps, which are described in the following.
Step 1: Get your service ready for Marblerun To get your service ready for Marblerun, you need to rebuild it with one of the supported runtimes:
EGo Edgeless RT Graphene Make your service use the provided TLS credentials Quick refresher: Marblerun&amp;rsquo;s Coordinator issues TLS credentials for each verified Marble (i.e., a service running in a secure enclave) as is described in our secrets management chapter.</description></item><item><title>Secrets management</title><link>https://marblerun.sh/docs/features/secrets-management/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/features/secrets-management/</guid><description>Secrets management The generation and the management of cryptographic keys and certificates for Marbles (i.e., containers running enclaves) are central duties of the Coordinator. Keys and certificates are passed to Marbles on startup via placeholders defined in the Manifest. You can learn more about this mechanism in our setting a manifest hands-on. Specifically, the Coordinator provides the following to Marbles.
Virtual sealing keys Shared symmetric keys TLS credentials Virtual sealing keys A key feature of Intel SGX is that it allows enclave software to derive so-called &amp;ldquo;sealing keys&amp;rdquo;.</description></item><item><title>On-premises</title><link>https://marblerun.sh/docs/deployment/on-prem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/deployment/on-prem/</guid><description>On-premises Marblerun deployment This guide walks you through setting up Marblerun for your on-premises deployment.
Prerequisites Hardware and firmware CPU To deploy Marblerun with Intel SGX, the machine or VM has to support Intel SGX. Particularly, Marblerun requires support for the SGX Datacenter Attestation Primitives (DCAP). You can verify if your CPU supports DCAP.
For more information read the Properly Detecting Intel Software Guard Extensions (Intel® SGX) in Your Applications article.</description></item><item><title>Marbles</title><link>https://marblerun.sh/docs/getting-started/marbles/</link><pubDate>Thu, 19 Nov 2020 16:33:26 +0100</pubDate><guid>https://marblerun.sh/docs/getting-started/marbles/</guid><description>Marbles Marbles are Marblerun&amp;rsquo;s data planes and run your application code in secure enclaves within otherwise regular Docker containers. Marbles communicate with the Coordinator via gRPC over TLS. See the Add a Service section on how to build and configure a Marble.</description></item><item><title>Verifying a deployment</title><link>https://marblerun.sh/docs/workflows/verification/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/verification/</guid><description>Verifying a deployment Marblerun provides a simple REST-API for clients to verify the confidentiality and integrity of the coordinator and the deployed Marbles.
Establishing trust in the Coordinator Marblerun exposes the /quote endpoint that returns a quote and a certificate chain consisting of a root and intermediate CA. The root CA is fixed for the lifetime of your deployment, while the intermediate CA changes in case you update the packages specified in your Manifest.</description></item><item><title>Kubernetes</title><link>https://marblerun.sh/docs/deployment/kubernetes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/deployment/kubernetes/</guid><description>Kubernetes Marblerun deployment This guide walks you through setting up Marblerun in your Kubernetes cluster.
Prerequisites SGX device plugin on Kubernetes Kubernetes manages hardware resources like Intel SGX through its device plugin framework. The SGX device plugin can either be deployed manually or as a DaemonSet in the cluster. Different vendors provide open-source device plugins for SGX:
Intel Azure Alibaba Cloud &amp;nbsp;Note If you are using a CC-enlightened, managed Kubernetes cluster, you will usually already have an SGX device plugin installed.</description></item><item><title>Kubernetes integration</title><link>https://marblerun.sh/docs/features/auto-injection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/features/auto-injection/</guid><description>Kubernetes integration Marblerun provides its data-plane configuration through Kubernetes resource definitions. For this, like regular service meshes, Marblerun uses Kubernetes' admission controllers.
Marblerun optionally injects tolerations and resources for its SGX device plugin. See the Kubernetes deployment section for more information.
You can enable auto-injection of the data-plane configuration for a namespace using the Marblerun CLI:
marblerun namespace add NAMESPACE [--no-sgx-injection] This will add the label marblerun/inject=enabled to the chosen namespace and allow the admission webhook to intercept the creation of deployments, pods, etc.</description></item><item><title>Supported runtimes</title><link>https://marblerun.sh/docs/features/runtimes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/features/runtimes/</guid><description>Supported runtimes Marblerun strives to be runtime-agnostic. Currently, supported runtimes are described below. More will follow in the future.
EGo EGo is the preferred way for writing confidential Go applications from scratch as well as porting existing ones. Usage is very similar to conventional Go programming. Continue with our building a service with EGo hands-on to use it with Marblerun.
Edgeless RT With Edgeless RT you can create confidential C++ applications with a low TCB.</description></item><item><title>Monitoring and logging</title><link>https://marblerun.sh/docs/workflows/monitoring/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/monitoring/</guid><description>Monitoring and logging As of now, the monitoring capabilities of Marblerun are basic. For status information, the Coordinator provides the /status endpoint in the client API. It returns the following information.
0 recovery mode: Found a sealed state of an old seal key. Waiting for user input on /recover. 1 uninitialized: Fresh start, initializing the Coordinator. 2 waiting for a manifest: Waiting for user input on /manifest 3 accepting marbles: Accepting Marbles through the Marble API More details about the Coordinator can be retrieved through its log as follows.</description></item><item><title>Planned features</title><link>https://marblerun.sh/docs/features/planned-features/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/features/planned-features/</guid><description>Planned features Among others, the following features are planned for Marblerun.
Splitting recovery key between a set of parties Fault-tolerant distribution of the Coordinator Transparent TLS for Marbles Constant-time crypto in the Coordinator Use online time sources for the verification of certificates and SGX collaterals</description></item><item><title>EGo</title><link>https://marblerun.sh/docs/building-services/ego/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/building-services/ego/</guid><description>Building a service: EGo To get your Go service ready for Marblerun, you possibly need to adapt its code slightly and you need to rebuild it. Details are given in the following.
&amp;nbsp;Note Future versions of EGo will support building Marblerun services with zero changes. Make your service use the provided TLS credentials If your service already uses TLS and gets the credentials from, e.g., a file, you just need to adapt the Manifest.</description></item><item><title>Standalone</title><link>https://marblerun.sh/docs/deployment/standalone/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/deployment/standalone/</guid><description>Standalone Marblerun deployment This guide walks you through deploying Marblerun standalone.
Prerequisites EGo is installed. Setup the Coordinator control plane You can download the latest release of our Coordinator control plane on GitHub. If you prefer to build from source please refer to our build guide.
You can then run the Coordinator&amp;rsquo;s enclave:
erthost build/coordinator-enclave.signed Per default, the Coordinator starts with the following default values. You can set your desired configuration by setting the environment variables.</description></item><item><title>Updating a Manifest</title><link>https://marblerun.sh/docs/workflows/update-manifest/</link><pubDate>Tue, 19 Jan 2021 15:33:00 +0100</pubDate><guid>https://marblerun.sh/docs/workflows/update-manifest/</guid><description>Updating a Manifest In order to ensure the confidentiality of a deployed application, Marblerun uses a Manifest to define the software packages and the infrastructure your deployment uses. To verify that your deployment has not been altered, the Manifest is usually set in stone after it was set to ensure no one can alter with your cluster.
Yet, updates play an important role to ensure your software stays secure. To avoid having to redeploy your application from scratch, Marblerun allows uploading a separate &amp;ldquo;Update Manifest&amp;rdquo; which increases the minimum SecurityVersion of one or multiple already deployed packages.</description></item><item><title>Graphene</title><link>https://marblerun.sh/docs/building-services/graphene/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/building-services/graphene/</guid><description>Building a service: Graphene Running a Graphene app with Marblerun requires some changes to its manifest. These are explained in the following. See also the helloworld example.
Requirements First, get Graphene up and running. You can use either the Building or Cloud Deployment guide to build and initially set up Graphene.
Before running your application, make sure you got the prerequisites for ECDSA remote attestation installed on your system. You can collectively install them with the following command:</description></item><item><title>Occlum</title><link>https://marblerun.sh/docs/building-services/occlum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marblerun.sh/docs/building-services/occlum/</guid><description>Building a service: Occlum Running an Occlum app with Marblerun requires some changes to its manifest.
Requirements Set up an environment to create Occlum images. For an easy start, we recommend that you use either the official Occlum Docker image or use our provided Dockerfile. For a working DCAP remote attestation environment, we recommend our cloud deployment guide.
To build your service, you can start with Occlum&amp;rsquo;s Introduction to get your application up and running, and then come back here to adapt it for use with Marblerun.</description></item><item><title>Updating a deployment</title><link>https://marblerun.sh/docs/workflows/updates/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/updates/</guid><description>Updating a deployment The following gives a walkthrough of typical deployment updates in a Kubernetes cluster and how to handle them with Marblerun.
Updating to a new Marblerun version When updating to a new Marblerun version, updates to both the control plane and data plane components may be required.
Updating the Coordinator Updating the Coordinator follows the regular steps for updating a deployment in Kubernetes.
kubectl -n marblerun set image deployment/marblerun-coordinator coordinator=ghcr.</description></item><item><title>Recovering the Coordinator</title><link>https://marblerun.sh/docs/workflows/recover-coordinator/</link><pubDate>Thu, 19 Nov 2020 15:53:14 +0100</pubDate><guid>https://marblerun.sh/docs/workflows/recover-coordinator/</guid><description>Recovering the Coordinator As described in the recovery chapter, different situations can require the recovery of the Coordinator. If the Coordinator finds a sealed state during its startup which it is unable to unseal using the host-specific SGX sealing key, it will wait for further instructions. You have two options:
Recover the sealed state by uploading the recovery secret, which was encrypted for the RecoveryKeys defined in the Manifest</description></item><item><title>Examples</title><link>https://marblerun.sh/docs/examples/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/examples/</guid><description>Examples Hello world We have two basic examples of how to build confidential applications with Marblerun.
See helloworld for how to integrate Marblerun with your Golang application. See helloc++ for how to integrate Marblerun with your C++ application. Emoji voting The popular Linkerd service mesh uses the simple and fun scalable emojivoto app as the default demo. You can find our confidential variant on GitHub. Your emoji votes have never been safer!</description></item><item><title>Changelog</title><link>https://marblerun.sh/docs/changelog/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/changelog/</guid><description/></item><item><title>Marblerun - Community</title><link>https://marblerun.sh/community/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/community/</guid><description> Community Marblerun is a community project and very much open to contributions. Let's work together and build the fabric for confidential cloud-native applications! &amp;nbsp;Get involved &amp;nbsp;Report a bug &amp;nbsp;GitHub &amp;nbsp;Get support &amp;nbsp;Chat on Discord &amp;nbsp;Send a mail &amp;nbsp;Get updates &amp;nbsp;Twitter</description></item></channel></rss>