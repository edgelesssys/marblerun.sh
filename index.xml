<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Marblerun - The service mesh for confidential computing on Marblerun - The Service Mesh for Confidential Computing</title><link>https://marblerun.sh/</link><description>Recent content in Marblerun - The service mesh for confidential computing on Marblerun - The Service Mesh for Confidential Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Nov 2020 16:44:36 +0100</lastBuildDate><atom:link href="https://marblerun.sh/index.xml" rel="self" type="application/rss+xml"/><item><title>Attestation</title><link>https://marblerun.sh/docs/features/attestation/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/features/attestation/</guid><description>Attestation Hardware-rooted remote attestation is a key ingredient for distributed confidential apps. Without it, services couldn&amp;rsquo;t trust each other and clients couldn&amp;rsquo;t trust the app. Thus, Marblerun relies heavily on the Data Center Attestation Primitives (DCAP) of the latest SGX-enabled Intel Xeon processors. You can learn more about DCAP here.
Internal attestation of Marbles The Coordinator verifies the identity and integrity of each newly spawned Marble before admitting it to the mesh.</description></item><item><title>Deploying Marblerun</title><link>https://marblerun.sh/docs/tasks/deploy/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/tasks/deploy/</guid><description>Deploying Marblerun This article assumes that you have an existing Azure Kubernetes Service (AKS) cluster. An AKS cluster can be created using the Azure CLI or the Azure portal. Alternatively, you can deploy the steps with minikube.
This article uses Helm 3 to install Marblerun. Make sure that you are using the latest release of Helm and have access to the Marblerun Helm repositories. For upgrade instructions, see the Helm install docs.</description></item><item><title>Hello World</title><link>https://marblerun.sh/docs/examples/helloworld/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/examples/helloworld/</guid><description>Hello world We have two basic examples of how to build confidential applications with Marblerun.
See helloworld for how to integrate Marblerun with your Golang application. See helloc++ for how integrate Marblerun with your C++ application.</description></item><item><title>Introduction</title><link>https://marblerun.sh/docs/introduction/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/introduction/</guid><description>Introduction Marblerun is a framework for creating distributed confidential-computing apps.
Build your confidential microservices with Edgeless RT, distribute them with Kubernetes on an SGX-enabled cluster, and let Marblerun take care of the rest. Deploy end-to-end secure and verifiable AI pipelines or crunch on sensitive big data in the cloud. Confidential computing at scale has never been easier.
Marblerun guarantees that the topology of your distributed app adheres to a Manifest specified in simple JSON.</description></item><item><title>Quickstart</title><link>https://marblerun.sh/docs/getting-started/quickstart/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/getting-started/quickstart/</guid><description>Quickstart Step 0: Setup Set up a Kubernetes cluster and install kubectl. Probably the easiest way to get started is to run Kubernetes on your local machine using Minikube. Another easy way is to use Azure Kubernetes Service (AKS), which offers SGX-enabled nodes.
Please also install Helm (&amp;ldquo;the package manager for Kubernetes&amp;rdquo;).
Step 1: Install the Coordinator onto the cluster Add the Edgeless Systems chart repository to Helm.
helm repo add edgeless https://helm.</description></item><item><title>Defining a Manifest</title><link>https://marblerun.sh/docs/tasks/define-manifest/</link><pubDate>Thu, 19 Nov 2020 16:44:36 +0100</pubDate><guid>https://marblerun.sh/docs/tasks/define-manifest/</guid><description>Defining a Manifest The Manifest is a simple JSON file that determines the key properties of your cluster: Packages, Infrastructures, Marbles, and RecoveryKey. This article describes how to define these in your manifest.json.
Manifest:Packages A package defines a specific container image in your application. It contains the secure enclave&amp;rsquo;s measurements and associated properties:
UniqueID: The enclave&amp;rsquo;s unique identifying measurement, called MRENCLAVE on SGX SignerID: The signer&amp;rsquo;s unique identifier, called MRSIGNER on SGX ProductID: The unique identifier of your product associated with the enclave SecurityVersion: The version number of your product associated with the enclave Debug: A flag indicating whether your enclave should be run in debug mode You can use any combination of these values depending on how you want to identify the image.</description></item><item><title>Confidential Emoji Voting</title><link>https://marblerun.sh/docs/examples/emojivoto/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/examples/emojivoto/</guid><description>Confidential emoji voting The popular Linkerd service mesh uses the simple and fun scalable emojivoto app as the default demo. You can find our confidential variant here. Your emoji votes have never been safer!</description></item><item><title>Recovery</title><link>https://marblerun.sh/docs/features/recovery/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/features/recovery/</guid><description>Recovery Persistent storage for confidential applications in the cloud requires a bit of attention. By design, SGX sealing keys are unique to a single CPU, which means using the default SGX sealing methods has some caveats. For example, sealing data while running on one host could mean the data can&amp;rsquo;t be unsealed when running on another host later on.
As described here, the Coordinator provides Marbles with virtual sealing keys making persistence straightforward for your applications.</description></item><item><title>Concepts</title><link>https://marblerun.sh/docs/getting-started/concepts/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/getting-started/concepts/</guid><description>Concepts This article describes the concepts of confidential computing and service meshes which are key to the Marblerun approach.
Confidential computing Confidential computing protects data in use by performing computation in hardware-based secure enclaves. The most prominent enclave to date is probably Intel SGX. Enclaves prevent unauthorized access or modification of applications and data while in use, thereby increasing the security assurances for organizations that manage sensitive and regulated data. For information about confidential computing, see the Confidential Computing Consortium white paper.</description></item><item><title>Secrets management</title><link>https://marblerun.sh/docs/features/secrets-management/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/features/secrets-management/</guid><description>Secrets management Two of the Coordinator&amp;rsquo;s central duties are the generation and the management of secrets for the Marbles (i.e., containers running enclaves). Specifically, the Coordinator deals with the following types of Marble secrets.
Virtual sealing keys Shared symmetric keys TLS credentials All of these secrets are handed to Marbles via placeholders in the Manifest as is described here.
Virtual sealing keys A key feature of Intel SGX is that it allows enclave software to derive so called &amp;ldquo;sealing keys&amp;rdquo;.</description></item><item><title>Setting a Manifest</title><link>https://marblerun.sh/docs/tasks/set-manifest/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/tasks/set-manifest/</guid><description>Setting a Manifest The Manifest is a JSON document that defines which services span the mesh and how they should be configured. It further defines what Infrastructure providers are allowed. You can set a Manifest through Marblerun&amp;rsquo;s Client REST-API. The endpoint for all Manifest operations is /manifest.
See the following Manifest for example (manifest.json).
{ &amp;#34;Packages&amp;#34;: { &amp;#34;backend&amp;#34;: { &amp;#34;UniqueID&amp;#34;: &amp;#34;000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f&amp;#34;, &amp;#34;ProductID&amp;#34;: 43, &amp;#34;SecurityVersion&amp;#34;: 1, &amp;#34;Debug&amp;#34;: false }, &amp;#34;frontend&amp;#34;: { &amp;#34;SignerID&amp;#34;: &amp;#34;c0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffee&amp;#34;, &amp;#34;ProductID&amp;#34;: 42, &amp;#34;SecurityVersion&amp;#34;: 3, &amp;#34;Debug&amp;#34;: true } }, &amp;#34;Marbles&amp;#34;: { &amp;#34;backend_first&amp;#34;: { &amp;#34;Package&amp;#34;: &amp;#34;backend&amp;#34;, &amp;#34;MaxActivations&amp;#34;: 1, &amp;#34;Parameters&amp;#34;: { &amp;#34;Files&amp;#34;: { &amp;#34;/tmp/defg.</description></item><item><title>Adding a service</title><link>https://marblerun.sh/docs/tasks/add-service/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/tasks/add-service/</guid><description>Adding a service Adding a service to your application requires two steps:
Building your service together with Marblerun to inject our Marble data plane. Adding the service to the Manifest so it will be recognized and managed by the Coordinator control plane. Building your service with Marblerun We distinguish two cases when building your confidential application with Marblerun:
Your service is written in Go
You need to build your project together with our Marble code We have an example on how to do this here Your service is written in any other language that can be compiled to binary code (e.</description></item><item><title>Planned features</title><link>https://marblerun.sh/docs/features/planned-features/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/features/planned-features/</guid><description>Planned features Among others, the following features are planned for Marblerun.
Support for Graphene and SGX-LKL to facilitate the porting of existing software Splitting recovery key between a set of parties Fault-tolerant distribution of the Coordinator Transparent TLS for Marbles Constant-time crypto in the Coordinator</description></item><item><title>Coordinator</title><link>https://marblerun.sh/docs/getting-started/coordinator/</link><pubDate>Thu, 19 Nov 2020 16:30:52 +0100</pubDate><guid>https://marblerun.sh/docs/getting-started/coordinator/</guid><description>Coordinator The Coordinator represents the control plane in Marblerun. It communicates with the data plane through gRPC and provides an HTTP-REST interface on the client-side. The Coordinator can be configured with several environment variables:
EDG_COORDINATOR_MESH_ADDR: The listener address for the gRPC server EDG_COORDINATOR_CLIENT_ADDR: The listener address for the HTTP server EDG_COORDINATOR_DNS_NAMES: The DNS names for the cluster&amp;rsquo;s root certificate EDG_COORDINATOR_SEAL_DIR: The file path for storing sealed data Client API The Client API is designed as an HTTP-REST interface.</description></item><item><title>Verifying a deployment</title><link>https://marblerun.sh/docs/tasks/verification/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/tasks/verification/</guid><description>Verifying a deployment An important feature of Marblerun is providing the ability to verifying the confidentiality and integrity of the whole application on the client-side. To that end, we provide a simple REST-API that clients can use before interacting with the application.
Establishing trust The first step is to establish trust with the whole microservice mesh. Therefore, Marblerun exposes the /quote endpoint that returns a quote and a root certificate for the whole mesh.</description></item><item><title>Marbles</title><link>https://marblerun.sh/docs/getting-started/marbles/</link><pubDate>Thu, 19 Nov 2020 16:33:26 +0100</pubDate><guid>https://marblerun.sh/docs/getting-started/marbles/</guid><description>Marbles Marbles represent the data plane in Marblerun and run your actual application code in secure enclaves within otherwise normal Docker containers. Marbles communicate with the Coordinator via gRPC over TLS. See the Add a Service section on how to build a Marble.
Marbles can be configured with several environment variables.
EDG_MARBLE_COORDINATOR_ADDR: The Coordinator&amp;rsquo;s address EDG_MARBLE_TYPE: The Marble&amp;rsquo;s Package EDG_MARBLE_DNS_NAMES: The DNS names in the Marble&amp;rsquo;s Certificate EDG_MARBLE_UUID_FILE: The file path for storing the Marble&amp;rsquo;s UUID, needed for restart persistence.</description></item><item><title>Monitoring and logging</title><link>https://marblerun.sh/docs/tasks/monitoring/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/tasks/monitoring/</guid><description>Monitoring and logging As of now, the monitoring capabilities of Marblerun are basic. For status information, the Coordinator provides the /status endpoint in the client API. It returns the following information.
0 recovery mode: Found a sealed state of an old seal key. Waiting for user input on /recover. 1 uninitialized: Fresh start, initializing the Coordinator. 2 waiting for a manifest: Waiting for user input on /manifest 3 accepting marbles: Accepting Marbles through the Marble API More details about the Coordinator can be retrieved through its log as follows.</description></item><item><title>Updating a deployment</title><link>https://marblerun.sh/docs/tasks/updates/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/tasks/updates/</guid><description>Updating a deployment The following gives a walkthrough of typical deployment updates in a Kubernetes cluster and how to handle them with Marblerun.
Updating to a new Marblerun version When updating to a new Marblerun version, updates to both the control plane and data plane components may be required.
Updating the Coordinator Updating the Coordinator follows the regular steps for updating a deployment in Kubernetes.
kubectl -n marblerun set image deployment/marblerun-coordinator coordinator=ghcr.</description></item><item><title>Recovering the Coordinator</title><link>https://marblerun.sh/docs/tasks/recover-coordinator/</link><pubDate>Thu, 19 Nov 2020 15:53:14 +0100</pubDate><guid>https://marblerun.sh/docs/tasks/recover-coordinator/</guid><description>Recovering the Coordinator As described here, different situations can require the recovery of the Coordinator. If the Coordinator finds a sealed state during its startup which it is unable to unseal using the host-specific SGX sealing key, it will wait for further instructions. You have two options:
Recover the sealed state by uploading the recovery secret, which was encrypted for the RecoveryKey defined in the Manifest
The recovery secret can be uploaded through the /recover client API endpoint.</description></item><item><title>Changelog</title><link>https://marblerun.sh/docs/changelog/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/changelog/</guid><description>Changelog</description></item><item><title>Marblerun - Community</title><link>https://marblerun.sh/community/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/community/</guid><description> Community Marblerun is a community project and very much open to contributions. Let's work together and build the fabric for confidential cloud-native applications! &amp;nbsp;Get involved &amp;nbsp;Report a bug &amp;nbsp;GitHub &amp;nbsp;Get support &amp;nbsp;Join us on Gitter &amp;nbsp;Send a mail &amp;nbsp;Get updates &amp;nbsp;Twitter</description></item></channel></rss>