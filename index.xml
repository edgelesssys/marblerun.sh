<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Marblerun</title>
    <link>https://marblerun.sh/</link>
    <description>Recent content on Marblerun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 14 Nov 2020 16:28:16 +0530</lastBuildDate><atom:link href="https://marblerun.sh/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Deploy Marblerun to your cluster</title>
      <link>https://marblerun.sh/docs/tasks/deploy/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/tasks/deploy/</guid>
      <description>Deploy Marblerun to your cluster Before you begin This article assumes that you have an existing AKS cluster. If you need an AKS cluster, see the AKS quickstart using the Azure CLI or using the Azure portal. Alternatively, you can deploy with minikube.
This article uses Helm 3 to install Marblerun. Make sure that you are using the latest release of Helm and have access to the Marblerun Helm repositories. For upgrade instructions, see the Helm install docs.</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://marblerun.sh/docs/examples/helloworld/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/examples/helloworld/</guid>
      <description>Hello World We have two basic examples of how to build confidential applications with Marblerun.
 See helloworld for how to integrate Marblerun with your Golang application. See helloc++ for how integrate Marblerun with your C++ application.  </description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://marblerun.sh/docs/introduction/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/introduction/</guid>
      <description>Introduction Marblerun (or Edgeless MR) is a framework for creating distributed confidential-computing apps.
Build your confidential microservices with Edgeless RT, distribute them with Kubernetes on an SGX-enabled cluster, and let Marblerun take care of the rest. Deploy end-to-end secure and verifiable AI pipelines or crunch on sensitive big data in the cloud. Confidential computing at scale has never been easier.
Marblerun guarantees that the topology of your distributed app adheres to a manifest specified in simple JSON.</description>
    </item>
    
    <item>
      <title>Quickstart</title>
      <link>https://marblerun.sh/docs/getting-started/quickstart/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/getting-started/quickstart/</guid>
      <description>Quickstart Step 0: Setup Set up a Kubernetes cluster and install kubectl. One easy way to get start is to run Kubernetes on your local machine using Minikube.
Please also install Helm (&amp;ldquo;the package manager for Kubernetes&amp;rdquo;).
Step 1: Install Coordinator onto the cluster Add the Edgeless Systems chart repository to Helm.
helm repo add edgeless https://helm.edgeless.systems helm repo update Install Marblerun&amp;rsquo;s Coordinator using Helm. Update the hostname with your cluster&amp;rsquo;s FQDN or use localhost for local testing.</description>
    </item>
    
    <item>
      <title>Service Authentication</title>
      <link>https://marblerun.sh/docs/features/service-authentication/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/features/service-authentication/</guid>
      <description>Service Authentication In a distributed confidential application it is of utmost importance to guarantee only trusted services are added to the mesh. Imagine an adversary could spawn a malicious instance of a backend service that would retrieve part of the data flow through load balancing. Your genuine instances would still guarantee the confidentiality of the data they receive, but part of the data would be leaked to the adversary.
Marblerun verifies the identity and integrity of each newly spawned service before adding it to the service mesh.</description>
    </item>
    
    <item>
      <title>Confidential Computing</title>
      <link>https://marblerun.sh/docs/getting-started/confidential-computing/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/getting-started/confidential-computing/</guid>
      <description>Confidential Computing Confidential Computing protects data in use by performing computation in hardware-based secure enclaves. The most prominent enclave to date is probably Intel SGX. Enclaves prevent unauthorized access or modification of applications and data while in use, thereby increasing the security assurances for organizations that manage sensitive and regulated data. For information about confidential computing, see the Confidential Computing Consortium white paper.</description>
    </item>
    
    <item>
      <title>Confidential Emoji Voting</title>
      <link>https://marblerun.sh/docs/examples/emojivoto/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/examples/emojivoto/</guid>
      <description>Confidential Emoji Voting The popular Linkerd service mesh uses the simple and fun scalable emojivoto app as the default demo. You can find our confidential variant here. Your emoji votes have never been safer!</description>
    </item>
    
    <item>
      <title>Infrastructure Validation</title>
      <link>https://marblerun.sh/docs/features/infrastructure-validation/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/features/infrastructure-validation/</guid>
      <description>Infrastructure Validation Marblerun allows you to define several VM types you want to whitelist for your application to run on. This way you can make sure that when you deploy your application to a cluster with VM of type A, nobody can substitute one of the nodes with a VM of type B.
The incentive is that an update of the Trusted Computing components as the CPU, Provisioning Certificate Enclave, or Quoting Enclave might contain security relevant changes.</description>
    </item>
    
    <item>
      <title>Setting a Manifest</title>
      <link>https://marblerun.sh/docs/tasks/set-manifest/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/tasks/set-manifest/</guid>
      <description>Set a Manifest The manifest is a JSON document that defines which services span the mesh and how they should be configured. It further defines what Infrastructure providers are allowed. You can set a Manifest through Marblerun&amp;rsquo;s Client REST-API. The endpoint for all Manifest operations is /manifest.
See the following manifest for example (manifest.jso
{ &amp;#34;Packages&amp;#34;: { &amp;#34;backend&amp;#34;: { &amp;#34;UniqueID&amp;#34;: &amp;#34;000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f&amp;#34;, &amp;#34;ProductID&amp;#34;: 1337, &amp;#34;SecurityVersion&amp;#34;: 1, &amp;#34;Debug&amp;#34;: false }, &amp;#34;frontend&amp;#34;: { &amp;#34;SignerID&amp;#34;: &amp;#34;c0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffeec0ffee&amp;#34;, &amp;#34;ProductID&amp;#34;: 42, &amp;#34;SecurityVersion&amp;#34;: 3, &amp;#34;Debug&amp;#34;: true } }, &amp;#34;Infrastructures&amp;#34;: { &amp;#34;Azure&amp;#34;: { &amp;#34;QESVN&amp;#34;: 2, &amp;#34;PCESVN&amp;#34;: 3, &amp;#34;CPUSVN&amp;#34;: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], &amp;#34;RootCA&amp;#34;: [3, 3, 3] }, &amp;#34;Alibaba&amp;#34;: { &amp;#34;QESVN&amp;#34;: 2, &amp;#34;PCESVN&amp;#34;: 4, &amp;#34;CPUSVN&amp;#34;: [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0], &amp;#34;RootCA&amp;#34;: [4, 4, 4] } }, &amp;#34;Marbles&amp;#34;: { &amp;#34;backend_first&amp;#34;: { &amp;#34;Package&amp;#34;: &amp;#34;backend&amp;#34;, &amp;#34;MaxActivations&amp;#34;: 1, &amp;#34;Parameters&amp;#34;: { &amp;#34;Files&amp;#34;: { &amp;#34;/tmp/defg.</description>
    </item>
    
    <item>
      <title>Adding a Service</title>
      <link>https://marblerun.sh/docs/tasks/add-service/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/tasks/add-service/</guid>
      <description>Add a service Adding a service to your application requires two steps:
 Building your service together with Marblerun to inject our Marble data plane. Adding the service to the manifest so it will be recognized and managed by the Coordinator control plane.  Building your service with Marblerun We distinguish two cases when building your confidential application with Marblerun:
  Your service is written in Go
 You need to build your project together with our Marble code We have an example on how to do this here    Your service is written in any other language that can be compiled to binary code (e.</description>
    </item>
    
    <item>
      <title>Remote Attestation</title>
      <link>https://marblerun.sh/docs/features/remote-attestation/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/features/remote-attestation/</guid>
      <description>Remote Attestation Remote attestation is a fundamental problem for a distributed confidential application. To keep things simple, Marblerun acts as certificate authority and issues one concise remote attestation statement for your whole distributed app. This can be used by anyone to verify the integrity of your distributed app.
To that end, the Coordinator provides a Client REST-API endpoint that allows any client to verify the topology of the distributed app adheres to the deployed manifest.</description>
    </item>
    
    <item>
      <title>Service Mesh</title>
      <link>https://marblerun.sh/docs/getting-started/service-mesh/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/getting-started/service-mesh/</guid>
      <description>Confidential Service Mesh A service mesh is an infrastructure layer for managing, observing, and securing communications in a container-based cluster. In the Kubernetes world, Istio, HashiCorp Consul, and Linkerd are the most popular general-purpose service meshes.
When we started looking into the concept of confidential microservices, we realized that there are additional challenges and requirements for service meshes in the conext of confidential computing.
 How to make an entire cluster or distributed app verifiable in a meaningful way from the outside?</description>
    </item>
    
    <item>
      <title>Client-Side verification</title>
      <link>https://marblerun.sh/docs/tasks/verification/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/tasks/verification/</guid>
      <description>Client-Side Verification An important feature of Marblerun is providing the ability to verifying the confidentiality and integrity of the whole application on the client-side. To that end, we provide a simple REST-API that clients can use before interacting with the application.
Establishing Trust The first step is to establish trust with the whole microservice mesh. Therefore, Marblerun exposes the /quote endpoint that returns a quote and a root certificate for the whole mesh.</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://marblerun.sh/docs/getting-started/overview/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/getting-started/overview/</guid>
      <description>Overview Marblerun consists of two logic parts, the control plane called Coordinator and the data plane called Marbles. The Coordinator needs to be deployed once in your cluster and the Marble layer needs to be integrated with each service. Marblerun is configured with a simple JSON document called the Manifest. It specifies the topology of the distributed app, the infrastructure properties, and provides configuration parameters for each service.
Manifest The manifest is a simple JSON file specifying three asset groups: Packages, Infrastructures, and Marbles:</description>
    </item>
    
    <item>
      <title>Changelog</title>
      <link>https://marblerun.sh/docs/changelog/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/docs/changelog/</guid>
      <description>Changelog </description>
    </item>
    
    <item>
      <title>Community</title>
      <link>https://marblerun.sh/community/</link>
      <pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate>
      
      <guid>https://marblerun.sh/community/</guid>
      <description> Community  We want to build a community and together make Marblerun the driving force behind Confidential Computing in the cloud. We&#39;d love to have you join our community as an early adopter or contributor.   Get Involved   Report a Bug     GitHub      Get Support   Join Us On Slack     Email Us      Get Updates   Twitter      </description>
    </item>
    
  </channel>
</rss>
