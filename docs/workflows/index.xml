<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Workflows on Marblerun - The Control Plane for Confidential Computing</title><link>https://marblerun.sh/docs/workflows/</link><description>Recent content in Workflows on Marblerun - The Control Plane for Confidential Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 14 Nov 2020 16:28:16 +0530</lastBuildDate><atom:link href="https://marblerun.sh/docs/workflows/index.xml" rel="self" type="application/rss+xml"/><item><title>Defining a manifest</title><link>https://marblerun.sh/docs/workflows/define-manifest/</link><pubDate>Thu, 19 Nov 2020 16:44:36 +0100</pubDate><guid>https://marblerun.sh/docs/workflows/define-manifest/</guid><description>Defining a manifest The manifest is a simple JSON file that determines the key properties of your cluster: Packages, Marbles, Secrets, and RecoveryKeys. This article describes how to define these in your manifest.json.
For a working example see the manifest of the emojivoto demo. See also the sample and template manifests.
Manifest:Packages The Packages section of the manifest lists all the secure enclave software packages that your application uses. A package is defined by the following properties.</description></item><item><title>Setting a manifest</title><link>https://marblerun.sh/docs/workflows/set-manifest/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/set-manifest/</guid><description>Setting a manifest The manifest is a JSON document that defines which services span the mesh and how they should be configured. It further defines what Infrastructure providers are allowed. You can set a manifest through Marblerun&amp;rsquo;s Client REST-API. The endpoint for all manifest operations is /manifest.
See the following manifest for example (manifest.json).
{ &amp;#34;Packages&amp;#34;: { &amp;#34;backend&amp;#34;: { &amp;#34;UniqueID&amp;#34;: &amp;#34;6b2822ac2585040d4b9397675d54977a71ef292ab5b3c0a6acceca26074ae585&amp;#34;, &amp;#34;ProductID&amp;#34;: 43, &amp;#34;SecurityVersion&amp;#34;: 1, &amp;#34;Debug&amp;#34;: false }, &amp;#34;frontend&amp;#34;: { &amp;#34;SignerID&amp;#34;: &amp;#34;43361affedeb75affee9baec7e054a5e14883213e5a121b67d74a0e12e9d2b7a&amp;#34;, &amp;#34;ProductID&amp;#34;: 42, &amp;#34;SecurityVersion&amp;#34;: 3, &amp;#34;Debug&amp;#34;: true } }, &amp;#34;Marbles&amp;#34;: { &amp;#34;backend_first&amp;#34;: { &amp;#34;Package&amp;#34;: &amp;#34;backend&amp;#34;, &amp;#34;MaxActivations&amp;#34;: 1, &amp;#34;Parameters&amp;#34;: { &amp;#34;Files&amp;#34;: { &amp;#34;/tmp/defg.</description></item><item><title>Adding a service</title><link>https://marblerun.sh/docs/workflows/add-service/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/add-service/</guid><description>Adding a service Adding a service to your application requires three steps, which are described in the following.
Step 1: Get your service ready for Marblerun To get your service ready for Marblerun, you need to rebuild it with one of the supported runtimes:
EGo Edgeless RT Graphene Make your service use the provided TLS credentials Skip this step, when using EGo with TTLS.
Quick refresher: Marblerun&amp;rsquo;s Coordinator issues TLS credentials for each verified Marble (i.</description></item><item><title>Verifying a deployment</title><link>https://marblerun.sh/docs/workflows/verification/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/verification/</guid><description>Verifying a deployment Marblerun provides a simple REST-API for clients to verify the confidentiality and integrity of the Coordinator and the deployed Marbles.
Establishing trust in the Coordinator Marblerun exposes the /quote endpoint that returns a quote and a certificate chain consisting of a root and intermediate CA. The root CA is fixed for the lifetime of your deployment, while the intermediate CA changes in case you update the packages specified in your manifest.</description></item><item><title>Monitoring and logging</title><link>https://marblerun.sh/docs/workflows/monitoring/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/monitoring/</guid><description>Monitoring and logging As of now, the monitoring capabilities of Marblerun are basic. For status information, the Coordinator provides the /status endpoint in the client API. It returns the following information.
0 recovery mode: Found a sealed state of an old seal key. Waiting for user input on /recover. 1 uninitialized: Fresh start, initializing the Coordinator. 2 waiting for a manifest: Waiting for user input on /manifest 3 accepting marbles: Accepting Marbles through the Marble API More details about the Coordinator can be retrieved through its log as follows.</description></item><item><title>Updating a manifest</title><link>https://marblerun.sh/docs/workflows/update-manifest/</link><pubDate>Tue, 19 Jan 2021 15:33:00 +0100</pubDate><guid>https://marblerun.sh/docs/workflows/update-manifest/</guid><description>Updating a manifest In order to ensure the confidentiality of a deployed application, Marblerun uses a manifest to define the software packages and the infrastructure your deployment uses. To verify that your deployment has not been altered, the manifest is usually set in stone after it was set to ensure no one can alter with your cluster.
Yet, updates play an important role to ensure your software stays secure. To avoid having to redeploy your application from scratch, Marblerun allows uploading a separate &amp;ldquo;update manifest&amp;rdquo; which increases the minimum SecurityVersion of one or multiple already deployed packages.</description></item><item><title>Managing secrets</title><link>https://marblerun.sh/docs/workflows/managing-secrets/</link><pubDate>Thu, 17 Jun 2021 13:36:38 +0200</pubDate><guid>https://marblerun.sh/docs/workflows/managing-secrets/</guid><description>Managing secrets In some cases users might need to access secrets generated by the Coordinator or pass in secrets to Marblerun themselves.
For example, an application might require an access token, to establish a secure connections to an external service. While setting the token directly in the manifest is an option, this would mean exposing the potentially confidential token to everyone with access to the manifest.
For such cases, Marblerun allows predefined users to upload secrets that have been predefined in the manifest.</description></item><item><title>Updating a deployment</title><link>https://marblerun.sh/docs/workflows/updates/</link><pubDate>Sat, 14 Nov 2020 16:28:16 +0530</pubDate><guid>https://marblerun.sh/docs/workflows/updates/</guid><description>Updating a deployment The following gives a walkthrough of typical deployment updates in a Kubernetes cluster and how to handle them with Marblerun.
Updating to a new Marblerun version When updating to a new Marblerun version, updates to both the control plane and data plane components may be required.
Updating the Coordinator Updating the Coordinator follows the regular steps for updating a deployment in Kubernetes.
kubectl -n marblerun set image deployment/marblerun-coordinator coordinator=ghcr.</description></item><item><title>Recovering the Coordinator</title><link>https://marblerun.sh/docs/workflows/recover-coordinator/</link><pubDate>Thu, 19 Nov 2020 15:53:14 +0100</pubDate><guid>https://marblerun.sh/docs/workflows/recover-coordinator/</guid><description>Recovering the Coordinator As described in the recovery chapter, different situations can require the recovery of the Coordinator. If the Coordinator finds a sealed state during its startup which it is unable to unseal using the host-specific SGX sealing key, it will wait for further instructions. You have two options:
Recover the sealed state by uploading the recovery secret, which was encrypted for the RecoveryKeys defined in the manifest</description></item></channel></rss>