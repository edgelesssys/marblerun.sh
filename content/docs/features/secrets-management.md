---
title: "Secrets management"
date: 2020-11-14T16:28:16+05:30
draft: false
weight: 3
---

# Secrets management

Two of the Coordinator's central duties are the generation and the management of secrets for the Marbles (i.e., containers running enclaves). Specifically, the Coordinator deals with the following types of Marble secrets.

* [Virtual sealing keys](#virtual-sealing-keys)
* [Shared symmetric keys](#shared-symmetric-keys)
* [TLS credentials](#tls-credentials)
* [User-definable secrets](#user-definable-secrets)

All of these secrets are handed to Marbles via placeholders in the Manifest as is described [here]({{< ref "docs/tasks/set-manifest.md" >}}).

## Virtual sealing keys

A key feature of Intel SGX is that it allows enclave software to derive so called "sealing keys". Generally, sealing keys are unique for a given enclave software / processor combination. Upon request from an enclave, the processor will deterministically derive the enclave's sealing key using a recipe somewhat reminiscent of the following: `hash(cpu_secret, hash(enclave_software), hash(enclave_parameters), ...)`. Enclave software uses sealing keys to encrypt data and persist it to local disk. This process is also referred to as "sealing". Sealing enables enclave software to persist sensitive data locally between restarts, e.g., after crashes or system reboots.

Crucially, in SGX, the aforementioned `cpu_secret` is hard-wired in silicon and is unique per physical processor. Thus, sealing keys do no commute between processors. Particularly in cloud settings, this becomes a problem: if a VM is scheduled on a different host, enclaves running within that VM cannot unseal their local data anymore, because the host's `cpu_secret` has changed.

To solve this problem, the Coordinator generates "virtual sealing keys" for Marbles. After successful validation of a Marble, the Coordinator injects a Marble's virtual sealing key through the `{{ hex .Marblerun.SealKey }}` placeholder in the `Parameters` section of the Manifest.

The Coordinator derives virtual sealing keys from respective Marble's ID and a master secret only known to the Coordinator. The ID is a public 128-bit value randomly generated by each Marble for itself upon startup and persisted in plaintext to local storage. Given this, two Marbles could end up with the same ID and virtual sealing key under certain circumstances. The security implications of this need to be taken into account when using virtual sealing keys. For example, when using virtual sealing keys with AES-GCM, one must only use cryptographically random nonces.

## Shared symmetric keys

While virtual sealing keys are used by individual Marbles, Marblerun also allows for the sharing of symmetric encryption keys between Marbles via placeholders in the Manifest. The Coordinator creates these keys once and provides them as parameters to corresponding Marbles. Marbles can use shared keys for a variety of tasks, including the bulk encryption of shared data.

As with virtual sealing keys, care has to be taken to not repeat nonces between Marbles when using shared keys with AES-GCM or similar encryption algorithms.

## TLS credentials

The Coordinator will generate a private TLS key for each new Marble and issue a corresponding X.509 certificate. Both are injected via the `{{ pem .Marblerun.MarbleCert.Private }}` and `{{ pem .Marblerun.MarbleCert.Cert }}` placeholders in the Manifest, respectively. The certificate is signed by the Coordinator's RootCA. Marbles can use these TLS credentials for establishing trust and secure communication channels internally between other Marbles and externally between clients. A Marble's certificate can be verified with respect to the Coordinator's RootCA certificate. The RootCA certificate can be injected into Marbles via the  `{{ pem .Marblerun.RootCA.Cert }}` placeholder. External clients can retrieve it in the remote attestation process described [here](({{< ref "docs/tasks/verification.md" >}})) in detail.

## User-definable secrets
Next to the predefined secrets, Marblerun also allows specifying additional secrets that can be generated on-the-fly and be either confined to a single marble or shared across all of them. These can be either symmetric keys or certificates, which can be referenced via the `{{ .Secret }}` prefix and loaded into environment variables or a file, similar to the predefined keys and their placeholders. Name, size, and duration of validity (for certificates) are user-definable, and supported output formats are `raw`, `hex`, `base64`, or `pem`.

Keys and certificates which are set to be unique to a Marble are not persisted on the disk automatically. They are generated by the Coordinator when a Marble is activated. For symmetric keys, the [HKDF](https://tools.ietf.org/html/rfc5869) scheme is used with an embedded secret to deterministically derive the same key across multiple activations of the same marble. Fresh X.509 certificates are generated on every activation with the Coordinator's root CA certificate as the issuer. 

This means that support for certificate pinning is not available so far. In case you need to pin a certificate, you should consider setting the secret to be shared across all marbles or to generate a fixed one in your application logic itself.
